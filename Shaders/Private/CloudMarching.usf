#include "/Engine/Private/Common.ush"
#define PI 3.1415
#define Grad4(P, I, VA, VB, S) lerp(dot(Hash4(P + VA), I - VA), dot(Hash4(P + VB), I - VB) ,S);
#define Grad2(P, I, VA, VB, S) lerp(dot(Hash2(P + VA), I - VA), dot(Hash2(P + VB), I - VB), S);
#define Grad3(P, I, VA, VB, S) lerp(dot(Hash3(P + VA), I - VA), dot(Hash3(P + VB), I - VB), S);

inline float2 Hash2(float2 Input)
{
    Input = float2(dot(Input, float2(123.1, 57.1)), dot(Input, float2(78, -21.7)));
    return -1.0 + 2.0 * frac(sin(Input) * 43758.5453123);
}

inline float3 Hash3(float3 Input)
{
    Input = float3(
            dot(Input, float3(21.5, 126.1, 49.8)),
            dot(Input, float3(-121.5, 403.5, 49.6)),
            dot(Input, float3(59.0, 54.0, -69.1))
            );
    return -1.0 + 2.0 * frac(sin(Input) * 1e5);
}

inline float4 Hash4(float4 Input)
{
    Input = float4(
            dot(Input, float4(21.5, 126.1, 49.8, -43.2)),
            dot(Input, float4(-121.5, 403.5, 49.6, 12.1)),
            dot(Input, float4(59.0, 54.0, -69.1, 9.7)),
            dot(Input, float4(70.6, -16.0, -19.5, 93.4))
            );
    return -1.0 + 2.0 * frac(sin(Input) * 1e5);
}

inline float SimplexNoise2(float2 Input)
{
    const float Skew = 0.211324865; // (3 - sqrt(3)) / 6 
    const float UnSkew = 0.366025404; //(sqrt(3) - 1) / 2
    
    float2 SqureInputI = floor(Input + (Input.x + Input.y) * UnSkew);
    float2 TriOffset = Input - SqureInputI + (SqureInputI.x + SqureInputI.y) * Skew;
    float Dir = step(TriOffset.y, TriOffset.x);
    float2 OtherCoorDir = float2(Dir, 1.0 - Dir);

    float2 TriOffsetB = TriOffset - 1.0 + 2.0 * Skew;
    float2 TriOffsetC = TriOffset - OtherCoorDir + Skew;
    
    float3 GradientList = float3(
        dot(TriOffset, Hash2(SqureInputI)),
        dot(TriOffsetB, Hash2(SqureInputI + 1.0)),
        dot(TriOffsetC, Hash2(SqureInputI + OtherCoorDir)));
    float3 Attention = max(0.5 - float3(dot(TriOffset, TriOffset), dot(TriOffsetB, TriOffsetB), dot(TriOffsetC, TriOffsetC)), 0);
    float3 n = Attention * Attention * Attention *Attention * GradientList;
    return dot(n, 70.0);
}

inline float4 MaxBit4(float4 Input)
{
    float4 a = step(0, Input - Input.yzwx);
    float4 b = step(0, Input - Input.zwxy);
    return a*b*(1 - a.wxyz);
}

inline float SimplexNoise4(float4 Input)
{
    const float Skew = 0.1382; //(5 - sqrt(5) / 20
    const float UnSkew = 0.3090; //(sqrt(5) - 1) / 4

    float4 SqureInputI = floor(Input + (Input.x + Input.y + Input.z + Input.w) * UnSkew);
    
    float4 TriOffset = Input - SqureInputI + (SqureInputI.x + SqureInputI.y + SqureInputI.z + SqureInputI.w) * Skew;
   
    float4 bit_1 = MaxBit4(TriOffset);  
    float4 TriOffset1 = TriOffset - bit_1 + Skew;

    float4 Inputtemp = TriOffset - bit_1 * 1e6;
    float4 bit_2 = MaxBit4(Inputtemp);
    float4 TriOffset2 = TriOffset1 - bit_2 + Skew;

    Inputtemp = Inputtemp - bit_2 * 1e6;
    float4 bit_3 = MaxBit4(Inputtemp);
    float4 TriOffset3 = TriOffset2 - bit_3 + Skew;
    
    float4 TriOffset4 = TriOffset - 1 + 4 * Skew;
    float2x3 gradientValue = float2x3(
        dot(TriOffset,  Hash4(SqureInputI)),
        dot(TriOffset1, Hash4(SqureInputI + bit_1)),
        dot(TriOffset2, Hash4(SqureInputI + bit_1 + bit_2)),
        dot(TriOffset3, Hash4(SqureInputI + bit_1 + bit_2 + bit_3)),
        dot(TriOffset4, Hash4(SqureInputI + float4(1, 1, 1, 1))),
        0
    );

    float2x3 Attention = max(0,
        0.5 - float2x3(
            dot(TriOffset,TriOffset),
            dot(TriOffset1, TriOffset1),
            dot(TriOffset2, TriOffset2),
            dot(TriOffset3, TriOffset3),
            dot(TriOffset4, TriOffset4),
            0
        )
    );
    float2x3 n = Attention * Attention * Attention * gradientValue;
    //return dot(TriOffset1, Hash4(SqureInputI + bit_1));
    return mul(float1x2(1, 1),mul(n, float3x1(70, 70, 70)))._11;
}

inline float OctaveSimplexNoise4(float4 Input)
{
    const float4x4 rot1 = float4x4(float4(0.92, 0.1, 0, -0.2), float4(0.1, 0.7, -0.1, 0.02), float4(0, -0.05, -0.72, -0.22), float4(-0.07,0.11,0.02,0.87));

    float v = 0.5 * SimplexNoise4(Input);
    v += 0.25 * SimplexNoise4(Input * 2.0);    v += 0.125 * SimplexNoise4(Input * 4.0);     v += 0.0625 * SimplexNoise4(Input * 8.0);
    return v;
}

inline float Perlin2(float2 Input)
{
    float2 fp = floor(Input);
    float2 fi = frac(Input);
    float2 w = fi * fi * (3.0 - 2.0 * fi);
    float horiV = Grad2(fp, fi, float2(0, 0), float2(1, 0), w.x)

    float horiU = Grad2(fp, fi, float2(0, 1), float2(1, 1), w.x)
    float res = lerp(horiV, horiU, w.y);
    return res;
}

inline float Perlin3(float3 Input)
{
    float3 fp = floor(Input);
    float3 fi = frac(Input);
    float3 w = fi * fi * (3.0 - 2.0 * fi);
    float a = Grad3(fp, fi, float3(0, 0, 0), float3(1, 0, 0), w.x)
    float b = Grad3(fp, fi, float3(0, 1, 0), float3(1, 1, 0), w.x)
    float c = Grad3(fp, fi, float3(0, 0, 1), float3(1, 0, 1), w.x)
    float d = Grad3(fp, fi, float3(0, 1, 1), float3(1, 1, 1), w.x)
    float e = lerp(a, b, w.y);
    float f = lerp(c, d, w.y);
    float h = lerp(e, f, w.z);
    return h;
}

inline float Perlin4(float4 Input)
{
    float4 fp = floor(Input);
    float4 fi = frac(Input);
    float4 w = fi * fi * (3.0 - 2.0 * fi);
    
    float a = Grad4(fp, fi, 0, float4(1, 0, 0, 0), w.x)
    float b = Grad4(fp, fi, float4(0, 1, 0, 0), float4(1, 1, 0, 0), w.x)
    float c = lerp(a, b, w.y);

    float d = Grad4(fp, fi, float4(0, 0, 1, 0), float4(1, 0, 1, 0), w.x)
    float e = Grad4(fp, fi, float4(0, 1, 1, 0), float4(1, 1, 1, 0), w.x)
    float f = lerp(d, e, w.y);
    
    float g = Grad4(fp, fi, float4(0, 0, 0, 1), float4(1, 0, 0, 1), w.x)
    float h = Grad4(fp, fi, float4(0, 1, 0, 1), float4(1, 1, 0, 1), w.x)
    float i = lerp(g, h, w.y);

    float j = Grad4(fp, fi, float4(0, 0, 1, 1), float4(1, 0, 1, 1), w.x)
    float k = Grad4(fp, fi, float4(0, 1, 1, 1), float4(1, 1, 1, 1), w.x)
    float l = lerp(j, k, w.y);

    float m = lerp(c, f, w.z);
    float n = lerp(i, l, w.z);

    float o = lerp(m, n, w.w);

    return o;
}

inline float SeamlessPerlin4(float4 Input)
{
    return Perlin4(Input);
}

inline float OctavePerlin2(float2 Input, float Base)
{
    float n = 0;
    float l = 1;
    for (int i = 0; i < 4; i++)
    {
        n += Perlin2(Base * Input) * l;
        Base *= 2;
        l *= 0.5;
    }
    return n;
}

inline float3 OctavePerlin3(float3 Input, float Base)
{
    float n = 0;
    float l = 1;
    for (int i = 0; i < 5; i++)
    {
        n += Perlin3(Base * Input) * l;
        Base *= 2;
        l *= 0.5;
    }
    return n;
}

inline float SeamlessPerlin2(float2 Input, float2 De)
{
    float nx =0.71+ cos(Input.x * 2 * PI) * De.x / (2 * PI);
    float ny =0.71+ cos(Input.y * 2 * PI) * De.y / (2 * PI);
    float nz =0.71+ sin(Input.x * 2 * PI) * De.x / (2 * PI);
    float nw =0.71+ sin(Input.y * 2 * PI) * De.y / (2 * PI);
    return SeamlessPerlin4(float4(nx, nz, ny, nw));
}
inline float SeamlessPerlin(float2 Input)
{
    float nx = cos(Input.x * 2 * PI) * sin(Input.y * 2 * PI);
    float ny = sin(Input.x * 2 * PI) * sin(Input.y * 2 * PI);
    float nz = cos(Input.y * 2 * PI);
    return OctavePerlin3(float3(nx, ny, nz), 4);

}

inline float SeamlessSimplex2(float2 Input, float2 De)
{
    float nx =0.71+ cos(Input.x * 2 * PI) * De.x / (2 * PI);
    float ny =0.71+ cos(Input.y * 2 * PI) * De.y / (2 * PI);
    float nz =0.71+ sin(Input.x * 2 * PI) * De.x / (2 * PI);
    float nw =0.71+ sin(Input.y * 2 * PI) * De.y / (2 * PI);
    float value = OctaveSimplexNoise4(float4(nx, nz, ny, nw));
    value = 0.5 + 0.5 * value;
    return value;
}
float4 RWSize;
RWTexture2D<float4> CoverMap;
[numthreads(32, 32, 1)]
void GenerateCoverNoise(uint3 id : SV_DispatchThreadID)
{
    CoverMap[id.xy] = SeamlessSimplex2(id.xy * 1.0 / RWSize.xy, float2(8.0, 8.0));
}
RWTexture2D<float4> DetailMap;
[numthreads(32, 32, 1)]
void GenerateDetailNoise(uint3 id : SV_DispatchThreadID)
{
    DetailMap[id.xy] = SeamlessPerlin2(id.xy / RWSize.xy, float2(10, 10));
}
RWTexture3D<float4> VolumeMap;
[numthreads(32, 32, 1)]
void GenerateVolumeNoise(uint3 id : SV_DispatchThreadID)
{
    VolumeMap[id] = 0;
}

